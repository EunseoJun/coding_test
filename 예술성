# 20251205
# 소요시간: 구현 1시간 40분, 최적화까지 2시간
# 생각보다 시간초과가 자주 나는거 같다
# 1. list 형태로 탐색하는 부분 고치기
# 2. 돌면서 한 번에 처리할 수 있는 부분 생각해보기

# # 예술성
# n*n 격자에서 진행
# 상하좌우로 인접해 있으면 동일 그룹
# 모든 그룹 쌍의 조화로움의 합
# 1. 초기 예술 점수
# 2. 그림에 대한 회전
# 2-1. 십자모양의 경우 반시계 방향으로 90도 회전
# 2-2. 십자 모양 외에는 개별적으로 시계방향 90도 회전
# 3. 초기 예술 점수. 1회전 이후의 점수, 2회전 이후의 점수, 3회전 이후의 예술 점수의 합을 출력

import sys
sys.stdin = open('input_6.txt', 'r')
from collections import deque

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
score = 0
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def group_score():
    touching = {}
    group_arr = [[0]*N for _ in range(N)]
    gcnt = 0
    art_score = 0
    group = []
    # 1. 그룹 찾기
    v = [[0]*N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if v[i][j] == 0:
                gcnt += 1
                q = deque()
                q.append((i, j))
                value = arr[i][j]
                v[i][j] = 1
                size = 1
                group_arr[i][j] = gcnt
                while q:
                    ci, cj = q.popleft()
                    for dr in range(4):
                        ni, nj = ci+dx[dr], cj+dy[dr]
                        if 0<=ni<N and 0<=nj<N:
                            if v[ni][nj]==0 and arr[ni][nj]==value:
                                v[ni][nj] = 1
                                q.append((ni, nj))
                                size += 1
                                group_arr[ni][nj] = gcnt
                            elif group_arr[ni][nj] != 0 and group_arr[ni][nj] != gcnt:
                                key = (min(gcnt, group_arr[ni][nj]), max(gcnt, group_arr[ni][nj]))
                                touching[key] = touching.get(key, 0) + 1
                group.append((value, size, gcnt))
    # 2. group 모든 쌍에 대해 예술성 계산
    # print(touching)
    for i in range(len(group)-1):
        for j in range(i+1, len(group)):
            v1, s1, gn1 = group[i]
            v2, s2, gn2 = group[j]
            # 맞닿은 변의 수 구하기
            key = (min(gn1, gn2), max(gn1, gn2))
            touch = touching.get(key, 0)
            # (1번 칸 수 + 2번 칸 수)*1번 숫자값*2번 숫자값*(a, b가 맞닿은 변의 수)
            sc = (s1+s2)*v1*v2*touch
            if sc>0:
                art_score += sc
    return art_score

def rotation():
    global arr
    # 1. 십자 부분 반시계 방향 회전
    temp_arr = [row[:] for row in arr]
    temp = [[0]*N for _ in range(N)]
    for _ in range(3):
        for i in range(N):
            for j in range(N):
                temp[j][N-i-1] = temp_arr[i][j]
        for i in range(N):
            for j in range(N):
                temp_arr[i][j] = temp[i][j]
    # 2. 남은 부분 각각 시계 방향 회전
    # temp2_arr = [row[:] for row in arr]
    c = N//2+1
    l = N//2
    coor = [(0, 0), (0, c), (c, 0), (c, c)]
    tsq = [[0]*l for _ in range(l)]
    for si, sj in coor:
        for li in range(l):
            for lj in range(l):
                tsq[lj][l-li-1] = arr[si+li][sj+lj]
        for li in range(l):
            for lj in range(l):
                temp_arr[si+li][sj+lj] = tsq[li][lj]
    arr = temp_arr

# 1. 초기 예술 점수
# 1-1. 그룹 찾고, 점수 계산=> group_score()
score += group_score()
# # 2. 1차 회전하기 rotation
rotation()
score += group_score()
# # 3. 2차 회전하기
rotation()
score += group_score()
rotation()
score += group_score()
print(score)
