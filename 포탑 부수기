# 20251123
# 3시간 34분
# 회고
# 3시간 좀 넘었을 때 다 맞췄는데 잡고 있었다
# 많이 늘었다
# 1. 함수 구현 끝났을 때마다 i,j 바꿔쓴거 없는지, %N 같은거 하드코딩 안했는지 3~4분은 다시 읽으면서 확인하기
# 2. 답 이상하면 문제 다시 읽으면서 놓친 로직 없나 확인하기
# 시간 있으면 tuple 사용해서 속도 최적화하기

# # 포탑 부수기
#
# N*M 격자, 모든 위치에는 포탑이 존재
# 각 포탑에는 공격력 존재, 상황에 따라 공격력이 줄거나 늘어남
# 공격력이 0 이하가 되면 포탑은 파괴되어 더 이상 공격 못함=>최초의 공격력이 0인 포탑은 없음
# 하나의 턴에 4가지 액션 순서대로 K번 반복됨, 부서지지 않은 포탑이 1개가 되면 즉시 중지
#
# 1. 공격자 선정
# 1-1. 가장 약한 포탑이 공격자로 선정됨
#     1-1-1. 공격력이 가장 낮은 포탑
#     1-1-2. 가장 최근에 공격한 포탑이 가장 약한 포탑 => 최근 공격 순서 => attack_turn
#     1-1-3. 행과 열의 합이 가장 큰 포탑이 가장 약한 포탑
#     1-1-4. 열 값이 가장 큰 포탑
# 1-2. 핸디캡이 적용되어 N+M만큼 공격력 증가
# 2. 공격자의 공격
# 2-1. 가장 강한 포탑이 공격 대상
#     2-1-1. 공격력이 가장 높은
#     2-1-2. 공격한지 가장 오래된 포탑
#     2-1-3. 행과 열의 합이 가장 작은 포탑
#     2-1-4. 열 값이 가장 작은 포탑
# 레이저 공격 시도=> 안되면 포탄
# 3. 레이저 공격
# 3-1. 상하좌우의 4개의 방향
# 3-2. 부서진 포탑이 있는 위치는 지날 수 없음
# 3-3. 막힌 방향으로 진행하고자 하면 반대편으로 나옴
# 3-4. 최단 경로로 공격, 우하좌상 우선 순위대로 경로 선택
# 3-5. 공격대상에게 공격력만큼의 피해를 입히고, 공격경로에 있는 포탑들은 절반만큼 피해(공격력//2 만큼)
# 4. 포탄 공격
# 4-1. 공격 대상은 공격력만큼 피해를 입음
# 4-2. 주변 8개 포탑도 피해를 입음(공격력//2)
# 5. 공격을 받아 공격력이 0 이하가 되면 부서짐
# 6. 포탑 정비, 공격과 무관했던 포탑들은 공격력이 1씩 오름
# 7. 전체 턴 종료 후 가장 강한 포탑의 공격력 출력

from collections import deque
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0] # 우하좌상

N, M, K = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
attacked_turn = [[0]*M for _ in range(N)] # 언제 공격했는지 저장하는 행렬

def get_attacker():
    # 1. 공격자 선정
    # 1-1. 가장 약한 포탑이 공격자로 선정됨
    #     1-1-1. 공격력이 가장 낮은 포탑
    #     1-1-2. 가장 최근에 공격한 포탑이 가장 약한 포탑 => 최근 공격 순서 => attack_turn
    #     1-1-3. 행과 열의 합이 가장 큰 포탑이 가장 약한 포탑
    #     1-1-4. 열 값이 가장 큰 포탑
    power = 5001
    candidate = []
    for i in range(N):
        for j in range(M):
            if arr[i][j] < power and arr[i][j]!=0:
                candidate = [[attacked_turn[i][j], i+j, j, [i, j], arr[i][j]]] # 디버깅용으로 공격력도 붙여놓음
                power = arr[i][j]
            elif arr[i][j] == power:
                candidate.append([attacked_turn[i][j], i+j, j, [i, j], arr[i][j]])
    candidate.sort(key=lambda x:(x[0], x[1], x[2]), reverse=True)
    attacker = candidate[0][3]

    return attacker

def get_attacked():
    power = 0
    candidate = []
    for i in range(N):
        for j in range(M):
            if arr[i][j] > power:
                candidate = [[attacked_turn[i][j], i + j, j, [i, j], arr[i][j]]]  # 디버깅용으로 공격력도 붙여놓음
                power = arr[i][j]
            elif arr[i][j] == power:
                candidate.append([attacked_turn[i][j], i + j, j, [i, j], arr[i][j]])
    candidate.sort(key=lambda x: (x[0], x[1], x[2]))
    # print(candidate)
    attacked = candidate[0][3]
    return attacked

def attack(attacker, attacked):
    potan = False
    # 3. 레이저 공격
    # 3-1. 우하좌상의 4개의 방향
    # 3-2. 부서진 포탑이 있는 위치는 지날 수 없음 => 현재 arr에서 0인 곳은 지나갈 수 없음
    # 3-3. 막힌 방향으로 진행하고자 하면 반대편으로 나옴
    # 3-4. 최단 경로로 공격, 우하좌상 우선 순위대로 경로 선택
    # 3-5. 공격대상에게 공격력만큼의 피해를 입히고, 공격경로에 있는 포탑들은 절반만큼 피해(공격력//2 만큼)
    candidate = []
    adi, adj = attacked
    q = deque()
    q.append((attacker, [0], [attacker])) # 현재 좌표, dr들, 연관포탑 리스트
    v = [[0]*M for _ in range(N)]
    v[attacker[0]][attacker[1]] = 1
    while q:
        coor, directs, rel = q.popleft()
        # print('xx', coor, directs, rel)
        ci, cj = coor[0], coor[1]
        for dr in range(4):
            ni, nj = int((ci+dx[dr])%N), int((cj+dy[dr])%M)
            if (ni, nj) == (adi, adj):
                tempd = directs[:]
                tempd.append(dr)
                tempr = rel[:]
                tempr.append([ni, nj])
                candidate.append([[ni, nj], tempd, tempr])
                # v[ni][nj] = 1 # cccc: 최단거리 할 때 우선순위대로 해서, 걍 도착하면 멈춰버리는걸로 했는데 이상하면 확인하기
                break
            elif arr[ni][nj]>0 and v[ni][nj] == 0:
                tempd = directs[:]
                tempd.append(dr)
                tempr = rel[:]
                tempr.append([ni, nj])
                q.append(([ni, nj], tempd, tempr))
                v[ni][nj] = 1
    if candidate == []:
        potan=True
    else:
        # print(candidate)
        _, _, rel = candidate[0]
        return rel
    # 포탄 공격
    if potan:
        # 4-1. 공격 대상은 공격력만큼 피해를 입음
        # 4-2. 주변 8개 포탑도 피해를 입음(공격력//2)
        # 5. 공격을 받아 공격력이 0 이하가 되면 부서짐
        rel = [attacker]
        for di, dj in [(-1,0),(1,0),(0,-1),(0,1),(-1,1),(1,1),(1,-1),(-1,-1)]:
            ni, nj = int((adi+di)%N), int((adj+dj)%M)
            if arr[ni][nj] > 0 and [ni, nj] != attacker:
                rel.append([ni, nj])
        rel.append(attacked)
        # print(rel)
    return rel





for t in range(1, K+1):
    # 1. 남은 포탑이 1개면 즉시 중지 + 부서진 포탑 0 처리
    alive = 0
    for i in range(N):
        for j in range(M):
            if arr[i][j] > 0:
                alive += 1
            else:
                arr[i][j] = 0
    if alive == 1:  break
    # 2. 공격자 선정 => attacker = get_attacker() => [ai, aj]
    attacker = get_attacker()
    # print(attacker)

    # 4. 공격대상 선정 => attacked = get_attacked() => [adi, adj]
    attacked = get_attacked()
    adi, adj = attacked
    # 3. 공격력 증가 시키기 N+M만큼
    ai, aj = attacker
    arr[ai][aj] += N + M

    # attacked_turn 여기서 올려주기
    attacked_turn[ai][aj] = t
    # 5. 공격 => attack(attacker, attacked) => arr 갱신, 공격 관련자들의 행렬 return
    # 공격 관련자들 행렬 예시 [[1, 2]...]
    relate = attack(attacker, attacked)
    # print(relate)

    # [[0, 1], [0, 2], [0, 3], [1, 3], [2, 3]] => 0번은 본인, -1은 공격대상
    # 공격 대상 공격
    # 관련자들 공격력//2만큼 공격
    attack_power = arr[ai][aj]
    arr[adi][adj] -= attack_power
    if arr[adi][adj] < 0:
        arr[adi][adj] = 0


    for ri, rj in relate[1:-1]:
        arr[ri][rj] -= int(attack_power//2)
        if arr[ri][rj] < 0:
            arr[ri][rj] = 0

    # 6. 공격 관련자들 + attacker 빼고 arr값 0 이상인 포탑들 +1씩
    for i in range(N):
        for j in range(M):
            if not ([i, j] in relate) and arr[i][j]>0:
                arr[i][j] += 1
    # print(arr)

m = 0
for i in range(N):
    for j in range(M):
        if arr[i][j] > m:
            m = arr[i][j]
print(m)
