# # 감시
# N*N 크기의 격자
# cctv는 k개 설치되어 있음 => 5종류
# cctv는 벽을 통과할 수 없음
# 다른 cctv는 통과 가능
# 사각지대의 최소 크기를 구해야 함
# 브루트포스? 백트래킹?
# import sys
# sys.stdin = open('input_6.txt', 'r')
from collections import deque

N, M = map(int, input().split())
org_arr = [list(map(int, input().split())) for _ in range(N)]

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1] #상우하좌 시계방향
min_side = N*M
cctv = []

for i in range(N):
    for j in range(M):
        if org_arr[i][j]>0 and org_arr[i][j]!=6:
            cctv.append((org_arr[i][j], i, j))

direct = {1: [[0], [1], [2], [3]],
          2: [[0,2], [1,3]],
          3: [[0, 1], [1, 2], [2, 3], [3, 0]],
          4: [[0, 1, 2], [1, 2, 3], [2, 3, 0], [3, 0, 1]],
          5: [[0, 1, 2, 3]]
          }

def zero_cnt(space):
    # print(space)
    global min_side
    temp_space = 0
    for i in range(N):
        for j in range(M):
            if space[i][j] == 0:
                temp_space += 1
    min_side = min(temp_space, min_side)

def fill_space(dr, x, y, space):
    for d in dr:
        q = deque()
        q.append((x, y))
        while q:
            ci, cj = q.popleft()
            ni, nj = ci+dx[d], cj+dy[d]
            if 0<=ni<N and 0<=nj<M:
                if space[ni][nj] == 0:
                    space[ni][nj] = -1
                    q.append((ni, nj))
                elif (space[ni][nj] > 0 and space[ni][nj]!=6) or space[ni][nj]==-1:
                    q.append((ni, nj))

        # print(space)
    return space

def dfs(level, arr):
    space = [row[:] for row in arr]

    if level==len(cctv):
        zero_cnt(space)
        return

    number, x, y = cctv[level]
    for dr in direct[number]:
        # space 채우고
        space = fill_space(dr, x, y, space)
        # dfs 다시 호출
        dfs(level+1, space)
        space = [row[:] for row in arr]

dfs(0, org_arr)
print(min_side)
