# 20251203
# 소요시간: 구현자체는 2시간 20분
# 최적화까지 하면 3시간
# not in이 매 번 조건 안에 들어가 있다면 list 형태에서의 탐색을 주의해야한다
# set으로 바꿔주면 실행 시간이 1/8로 줄음..!!
# 구현 할 때는 그냥 구현하고 시간초과 오류가 나면 set으로 바꿔서 최적화할것
# set은 remove, add를 활용한다
# 처음에 문제가 생겼었는데 좀 긴 테스트케이스라도 차근차근 확인하니 2시간 넘었을 쯤 구현이 끝났다
# 실전에서도 차근차근 구현하기
# 함수 하나 구현하고 끝 케이스와 같은 부분에서 문제 안생기는지 한 번 더 생각하기

# # AI로봇청소기
# N*N 격자에서 진행
# 각 격자에는
# 1. 먼지가 있거나(1~100의 먼지의 양(p)을 가짐)
# 2. 아무런 먼지가 없거나
# 3. 물건이 위치할 수 있음
# 4. 각각의 로봇청소기는 초기 위치를 가짐. 해당 위치에는 먼지 없음이 보장됨
# 테스트는 다음과 같이 진행
# 1. 청소기 이동
# 1-1. 로청은 순서대로 이동거리가 가장 가까운 오염된 격자로 이동
# 1-2. 물건이 있거나 청소기가 있는 격자로는 이동할 수 없음
# 1-3. 가장 가까운 격자가 여러개일 경우 r작>c작
# 2. 청소
# 2-1. 청소기는 바라보고 있는 방향을 기준으로 본인 위치 격자, 왼쪽 격자, 위쪽, 오른쪽 격자 청소 가능
# 2-2. 4가지 방향 중에서 청소할 수 있는 먼지량이 가장 큰 방향에서 청소를 시작
# 2-3. 격자마다 청소할 수 있는 최대 먼지량은 20
# 2-4. 합이 같은 방향이 여러개면 우하좌상의 우선순위로 선택
# 2-5. 청소는 청소기마다 순서대로 => 바로 갱신하면 됨
# 3. 먼지 축적
# 3-1. 먼지가 있는 모든 격자에 동시에 5씩 추가됨
# 4. 먼지확산
# 4-1. 깨끗한 격자에 주변 4방향 격자의 먼지량을 10으로 나눈만큼 먼지 생김=>int(dust/10)
# 5. 출력
# 5-1. 전체 공간의 총 먼지량 출력
# 6. 위 과정을 L번 반복

import sys
sys.stdin = open('input_6.txt', 'r')
from collections import deque

N, K, L = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
rb = []
rb_set = set()
for _ in range(K):
    r, c = map(int, input().split())
    rb.append((r-1, c-1))
    rb_set.add((r-1, c-1))

def move_rb(): # 순서대로 이동 하나씩 업데이트
    for idx in range(K):
        cand = []
        v = [[0]*N for _ in range(N)]
        ri, rj = rb[idx]
        v[ri][rj] = 1
        q = deque()
        q.append((ri, rj, 0))
        min_dist = N*N*2
        other_rb_set = rb_set - {rb[idx]}
        while q:
            ci, cj, dist = q.popleft()
            # temp_rb = rb[:]
            # temp_rb.pop(idx)

            # print(rb)
            # print(temp_rb)
            if 0 <= ci < N and 0 <= cj < N and arr[ci][cj] > 0 and (ci, cj) not in other_rb_set and dist<=min_dist:
                if dist < min_dist:
                    cand = [[dist, ci, cj]]
                    min_dist = dist
                elif dist == min_dist:
                    cand.append([dist, ci, cj])
            else:
                for x, y in [(-1,0),(1,0),(0,-1),(0,1)]:
                    ni, nj = ci+x, cj+y
                    if 0<=ni<N and 0<=nj<N and arr[ni][nj]>-1 and (ni,nj) not in rb_set and v[ni][nj]==0:
                        q.append((ni, nj, dist+1))
                        v[ni][nj]=1
        if cand == []: # 못움직이면,, 안움직이기
            pass
        else:
            cand.sort()
            rb_set.remove((ri, rj))
            ri, rj = cand[0][1], cand[0][2]
            rb_set.add((ri, rj))
            rb[idx] = (ri, rj)

def clean():
    dx = [0, 1, 0, -1] # 우하좌상
    dy = [1, 0, -1, 0]
    # print('init_arr', arr)
    for idx in range(K):
        # 1. 4가지 경우의 수에 대해 계산 => max 방향 갱신하면서 => 우하좌상의 우선순위
        dr_cand = []
        max_dust = -1
        dust = 0
        ri, rj = rb[idx]
        for sdr in range(4):
            # print(sdr)
            if arr[ri][rj]>20:
                dust = 20
            else:
                dust = arr[ri][rj]
            for dr in range(-1, 2, 1):
                ndr = int((sdr+dr)%4)
                # print(ndr, end=' ')
                ni, nj = ri+dx[ndr], rj+dy[ndr]
                # if 0<=ni<N and 0<=nj<N and (ni, nj) not in rb and arr[ni][nj]>-1: # cccc 청소기가 있어도 상관 없으면 조건 바꾸기
                if 0 <= ni < N and 0 <= nj < N and arr[ni][nj] > -1:
                    if arr[ni][nj]>20:
                        dust += 20
                    else:
                        dust += arr[ni][nj]
            # print()
            if dust>max_dust:
                dr_cand = [sdr]
                max_dust = dust
            elif dust==max_dust:
                dr_cand.append(sdr)
        if dr_cand == []: #비는 경우... 있을까?
            pass
        else:
            dr_cand.sort()
            cdr = dr_cand[0]
            # 본인 자리 청소
            if arr[ri][rj]<=20:
                arr[ri][rj] = 0
            else:
                arr[ri][rj] -= 20
            for dr in range(-1, 2, 1):
                ddr = int((cdr+dr))%4
                ci, cj = ri+dx[ddr], rj+dy[ddr]
                # print(ci, cj)
                # if 0<=ci<N and 0<=cj<N and arr[ci][cj]>0 and (ci,cj) not in rb: # cccc 만약에 다른 청소기 있어도 청소 가능하면 수정
                if 0<=ci<N and 0<=cj<N and arr[ci][cj]>0:
                    if arr[ci][cj]<=20:
                        arr[ci][cj] = 0
                    else:
                        arr[ci][cj] -= 20
        # print(idx, dr_cand[0], max_dust)
        # print(arr)

def spread():
    temp_arr = [[0]*N for _ in range(N)]
    dust = 0
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 0:
                dust = 0
                for x, y in [(-1,0),(1,0),(0,-1),(0,1)]:
                    ni, nj = i+x, j+y
                    if 0<=ni<N and 0<=nj<N and arr[ni][nj]>0:
                        dust += arr[ni][nj]
                temp_arr[i][j] += int(dust/10)
    # 갱신하기
    for i in range(N):
        for j in range(N):
            if temp_arr[i][j]>0:
                arr[i][j] = temp_arr[i][j]


for t in range(L):
    # 먼지 있는 곳 없으면 0 출력
    # 1. 청소기 이동 => move_rb() 로봇 위치 갱신
    move_rb()
    # 2. 청소 => clean() => 본인 포함, 4가지 방향 청소량 최대화
    clean()
    # 3. 먼지 축적 => 동시에 5씩 추가
    for i in range(N):
        for j in range(N):
            if arr[i][j]>0:
                arr[i][j] += 5
    # print(arr)
    # 4. 먼지 확산 spread()=> 임시 행렬에 만들어두고 복사하기
    spread()
    # print(arr)
    result = 0
    for i in range(N):
        for j in range(N):
            if arr[i][j]>0:
                result+=arr[i][j]
    print(result)
    # print(t, '------------')
