# 20251121
# 4시간 43분
# 회고
# 정말 별 거 아닌 좌표 때문에 구현 자체는 2시간만에 끝났는데 디버깅을 못했다
# 좌표 회전 같은거 할 때에는 처음부터 로직을 다 설계해놓기!!!!
# 좌표회전 기초문제 다시 풀어서 완전히 체화하기

# # 메이즈러너
#
# M명의 참가자
# N*N크기의 격자
# 빈 칸, 출구, 벽(1~9의 내구도, 회전할 때마다 내구도 1씩 깎임)=>내구도가 0이 되면 빈 칸
# 1. 1초마다 모든 참가자는 1칸씩 움직임
# 1-1. 최단거리는 abs(x1-x2)+abs(y1-y2)
# 1-2. 상하좌우로 움직임. 벽이 없는 곳으로 이동 가능
# 1-3. 움직인 칸은 현재 머무르는 칸보다 출구까지의 최단거리가 가까워야 함
# 1-4. 움직일 수 있는 칸 2개 이상 => 상or하를 우선으로 함
# 1-5. 참가자가 움직일 수 없다면 움직이지 않음
# 1-6. 한 칸에 2명 이상의 참가자 있을 수 있음 !!!!!!!!!
# 2. 미로의 회전
# 2-1. 한 명 이상의 참가자가 포함된 가장 작은 정사각형을 잡음
# 2-2. 가장 작은 크기를 갖는 정사각형이 2개 이상이면, 좌상r좌표 작은것 우선, c좌표 작은것 우선
# 2-3. 정사각형은 시계 방향으로 90도 회전, 회전된 벽은 내구도가 1씩 깎임
# 3. K초 동안 위 과정 반복, 참가자가 모두 탈출하면 게임 끝.
# 3-1. 게임이 끝났을 때 모든 참가자들의 이동 거리 합과 출구 좌표를 출력
from collections import deque

N, M, K = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
member = [[] for _ in range(M)]
ex = [0]*M
for m in range(M):
    i, j = map(int, input().split())
    member[m] = [i-1, j-1]
ei, ej = map(int, input().split())
ei -= 1
ej -= 1
arr[ei][ej] = -1 # 출구는 -1로 표시
move_cnt = [0]*(M) # 움직인 횟수 저장

dx = [-1, 1, 0, 0] # 우선 순위 맞춰서 상하좌우
dy = [0, 0, -1, 1]
def move():
    # 1-1. 최단거리는 abs(x1-x2)+abs(y1-y2)
    # 1-2. 상하좌우로 움직임. 벽이 없는 곳으로 이동 가능
    # 1-3. 움직인 칸은 현재 머무르는 칸보다 출구까지의 최단거리가 가까워야 함
    # 1-4. 움직일 수 있는 칸 2개 이상 => 상or하를 우선으로 함
    # 1-5. 참가자가 움직일 수 없다면 움직이지 않음
    # 1-6. 한 칸에 2명 이상의 참가자 있을 수 있음
    # 1. 1초마다 모든 참가자는 1칸씩 움직임
    for idx in range(len(member)):
        if ex[idx] == 1:    continue
        i, j = member[idx][0], member[idx][1]
        move_list = []
        min_dist = abs(ei-i)+abs(ej-j)
        for dr in range(4):
            # 기존 거리보다 가까워짐+벽 없음=>이동
            ni, nj = i+dx[dr], j+dy[dr]
            dist = abs(ei - ni) + abs(ej - nj)
            if 0<=ni<N and 0<=nj<N:
                if arr[ni][nj]<=0 and min_dist>dist:
                    min_dist = dist
                    move_list.append([dist, dr]) #상하 우선하기 위해서
        if move_list == []:  continue
        move_list.sort(key=lambda x:(x[1], x[0]))
        mdr = move_list[0][1]

        if (i+dx[mdr], j+dy[mdr]) == (ei, ej):
            move_cnt[idx] +=1
            ex[idx] = 1
            member[idx] = []
        else:
            move_cnt[idx] +=1
            member[idx] = [i+dx[mdr], j+dy[mdr]]


def rotate():
    global ei
    global ej
    length = 1
    scand = []
    br = False
    for ln in range(length, N):
        # 해당 length에서 충족되었으면 다음 length부터는 순회 안함
        if br:  break
        for i in range(N):
            for j in range(N):
                # 좌상단 좌표라고 생각하고 순회
                # 사각형의 좌상, 우하 좌표 구하기
                slui = i
                sluj = j
                srdi = i+ln
                srdj = j+ln
                # 1차 조건: ei, ej가 좌표 안에 있는가?
                if 0<=srdi<N and 0<=srdj<N:
                    if slui<=ei<=srdi and sluj<=ej<=srdj:
                        # 2차 조건 사람이 안에 1명 이상 있는가?
                        for idx in range(len(member)):
                            if ex[idx] == 0:
                                m = member[idx]
                                mi, mj = m[0], m[1]
                                if slui<=mi<=srdi and sluj<=mj<=srdj:
                                    if [i, j] not in scand:
                                        scand.append([i, j, ln]) # x, y, 길이
                                        br = True
                                        break
    scand.sort(key=lambda x:(x[0], x[1]))
    si, sj, sl = scand[0] # 사각형 골랐음
    # 이제 회전!!!
    # 1. 사각형 돌리기
    temp = [[0]*N for _ in range(N)]
    for i in range(0, sl+1):
        for j in range(0, sl+1):
            temp[i][j] = arr[si+i][sj+j]

    # 2. 돌린 사각형 내의 벽 내구도 1씩 깎기
    turn = []
    for i in range(sl + 1):
        for j in range(sl + 1):
            turn.append([[si + j, sj+sl-i], [i+si, j+sj]])
            # arr[si+i][sj+j] = temp[j][(sl+1)-i-1]
            if temp[i][j] > 0:
                arr[si + j][sj+sl-i] = temp[i][j]-1
            elif temp[i][j] == -1:
                arr[si + j][sj + sl - i] = temp[i][j]
                ei = si + j
                ej = sj + sl - i
            else:
                arr[si + j][sj + sl - i] = temp[i][j]
            

    # 3. 사각형 내에 있던 member들 돌리기
    for idx in range(M):
        if ex[idx] == 0:
            mi, mj = member[idx][0], member[idx][1]
            for c in range(len(turn)):
                if [mi, mj] == [turn[c][1][0], turn[c][1][1]]:
                    member[idx] = [turn[c][0][0], turn[c][0][1]]
    # print('tt', turn)
    # print('temp_mem', member)


for t in range(1, K+1):
    if 0 not in ex:   break
    # 1. 참가자들 움직이기 => move()
    move()
    # print(member)
    # 2. 작은 사각형 잡고 회전 => rotate()
    if not 0 in ex: break
    rotate()
    # print('turn=--------------', t)
    # print('exit', ei, ej)
    # print('arr', arr)
    # print('mb', member)
    # print('ex', ex)

print(sum(move_cnt))
print(ei+1, ej+1)
    # 2-1. 작은 사각형 브루트포스
    # 2-2. 돌리고 사각형 내의 벽들의 내구도 1씩 깎기
