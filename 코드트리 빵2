# #20251128
# 소요시간: 1시간 4분
# 회고
# 단순한 최단거리 문제는 그렇게 어렵지 않은거 같다
# 새로운 유형의 문제가 나왔을 때 구현할 수 있어야 함

# 코드트리 빵

# m명의 사람, 1분에는 1번재, m분에는 m번째 사람이 움직임
# 베이스캠프 => 편의점으로 이동
# n*n 크기의 격자 위에서 진행

# 1. 격자에 있는 모두가 본인이 가고싶은 편의점을 향해 1칸 움직임
# 1-1. 최단거리로 움직이며, 최단거리가 여러개면 상좌우하의 순서대로 움직임
# 2. 편의점에 도착하면 편의점에서 멈춤, 이때부터 다른 사람들은 해당 편의점이 있는 칸을 못지나감
# => 사람들의 이동이 모두 끝나고 통행금지, 이동 끝난 후 이동금지처리
# 3. 현재 시간이 t분일 때 t<=m이면 t번 사람은 편의점과 가장 가까운 베이스 캠프에 들어감
# => t분이 되면 t번 사람이 베이스캠프로 감
# 3-1. 최단거리상으로 가장 가까운 베이스캠프로 들어감
# 3-2. 베이스캠프에 들어가면 바로 통행금지
# 4. 모든 사람이 몇 분 뒤에 편의점에 도착하는지 출력
dx = [-1, 0, 0, 1] # 상좌우하
dy = [0, -1, 1, 0]
from collections import deque

N, M = map(int, input().split())
# 베캠 위치
arr = [list(map(int, input().split())) for _ in range(N)]
conv = []
for _ in range(M):
    a, b = map(int, input().split())
    conv.append((a-1, b-1))
arrive = [0]*M
road = [[0]*N for _ in range(N)]
player = [[] for _ in range(M)]

def init_basecamp(idx):
    candidate = []
    cvi, cvj = conv[idx]
    q = deque()
    q.append((cvi, cvj, 0)) # 위치, 거리
    v = [[0]*N for _ in range(N)]
    v[cvi][cvj] = 1
    min_dist = N*N*2
    while q:
        ci, cj, dist = q.popleft()
        if dist<=min_dist:
            if arr[ci][cj] == 1:
                candidate.append([dist, ci, cj])
                min_dist = dist
            # 코드 패턴 정립하기
            else:
                for dr in range(4):
                    ni, nj = ci+dx[dr], cj+dy[dr]
                    if 0<=ni<N and 0<=nj<N and v[ni][nj]==0 and road[ni][nj]==0:
                        v[ni][nj] = 1
                        q.append((ni, nj, dist+1))
    candidate.sort()
    player[idx] = [candidate[0][1], candidate[0][2]]
    road[candidate[0][1]][candidate[0][2]] = 1

def conv_bfs(idx):
    candidate = []
    pi, pj = player[idx]
    q = deque()
    q.append((pi, pj, [], 0)) # 시작 좌표, 처음 움직인 위치(도착 칸), 거리
    v = [[0]*N for _ in range(N)]
    v[pi][pj] = 1
    min_dist = N*N*2
    while q:
        ci, cj, mv, dist = q.popleft()
        if dist<=min_dist:
            if (ci, cj) == conv[idx]:
                candidate.append([dist, mv])
                min_dist = dist
            else:
                for dr in range(4):
                    ni, nj = ci + dx[dr], cj + dy[dr]
                    if 0 <= ni < N and 0 <= nj < N and v[ni][nj] == 0 and road[ni][nj] == 0:
                        v[ni][nj] = 1
                        if mv == []:
                            q.append((ni, nj, [ni,nj], dist + 1))
                        else:
                            q.append((ni, nj, mv, dist + 1))
    candidate.sort(key=lambda x:(x[0]))
    player[idx] = candidate[0][1]
    return idx, player[idx][0], player[idx][1]

def move_conv():
    moved = []
    # 1. []일 때 제외하고 한 칸씩 이동
    for idx in range(M):
        if player[idx] != [] and arrive[idx]==0:
            midx, ni, nj = conv_bfs(idx)
            moved.append((midx, ni, nj))
    # 2. 이동한 좌표가 편의점이면 road에 표시
    for m in moved:
        midx, ni, nj = m
        if conv[midx]==(ni, nj):
            arrive[midx] = 1
            road[ni][nj] = 1

t = 0
while True:
    # 모두 도착했으면 종료
    if 0 not in arrive:
        break
    # 1. 편의점으로 1칸 이동=>t가 0보다 클때
    # 이동하고, 움직인 칸 저장해뒀다가 conv 들어갔으면 도착 처리+통행금지 처리
    if t>0:
        move_conv()
    # 2. 가까운 베이스캠프로 이동: t가 m보다 작거나 같을 때까지
    if t<M:
        init_basecamp(t)
    t+=1

print(t)


