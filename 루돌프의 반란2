# 20251129
# 소요시간: 1시간 44분
# 회고
# 워낙 여러번 푼 문제라 금방 푼거 같기도
# 구현 방향 자체는 확립된거 같다
# 그래도 몇 번씩 틀리는 부분이 있는데 잘 확인하면서 할것
# 안 틀리려면 arr 결과만 보고 맞게 돈다가 아니라, 
# 연관 있는 모든 변수를 턴마다 찍어서 갱신이 잘되나 확인해야함

# # 루돌프의 반란
# 1~P번까지의 산타
# 1. 겜판 구성
# N*N크기의 격자 => (r, c)
# M턴에 걸쳐 진행됨, 매 턴마다 루돌프와 산타들이 1번씩 움직임
# 루돌프 1 => 1~P번 산타까지 순서대로 움직임
# 두 칸 사이의 거리는 (r1-r2)**2+(c1-c2)**2
# 2. 루돌프의 움직임
# 2-1. 루돌프는 가장 가까운 산타를 향해 1칸 돌진, 게임에서 탈락하지 않은 산타중!!
# 2-2. 가까운 산타가 둘 이상이면 r큰>c큰
# 2-3. 루돌프는 상하좌우대각선 8방향 중 하나로 돌진
# 3. 산타의 움직임
# 3-1. 산타는 1~P번까지 순서대로 움직임=>상하좌우 우선 순위로 움직임
# 3-2. 기절했거나 탈락 산타는 못움직임
# 3-3. 루돌프에게 가장 가까워지는 방향으로 1칸 이동
# 3-4. 다른 산타가 있거나, 겜판 밖으로는 못나감
# 3-5. 움직일 수 있는 칸이 있어도 루돌프로부터 멀어지면 움직이지 않음
# 4. 충돌
# 4-1. 산타 루돌프가 같은 칸이면 충돌 발생
# 4-2. 루돌프가 움직이면 산타가 C만큼 점수=>루돌프가 이동해온 방향으로 C칸만큼 움직임
# 4-3. 산타가 움직여서 충돌하면 D만큼 점수=>자신이 이동해온 '반대'방향으로 D칸만큼 밀려남
# 4-4. 겜판 밖으로 나갔으면 산타는 탈락
# 4-5. 밀려난 칸에 다른 산타가 있으면 상호작용
# 5. 상호작용
# 5-1. 착지하는 칸에 다른 산타가 있으면 연쇄적으로 1칸씩 밀림을 반복함
# 5-2. 겜판 밖으로 나가면 탈락
# 6. 기절
# 6-1. 산타는 루돌프와의 충돌 후 기절, 현재가 K턴이면 K+1번째 턴까지 기절=>K+2부터 움직임
# 6-2. 못움직임, 충돌이나 상호작용은 가능, 돌진대상 가능
# 7. 겜 종료
# 7-1. M번의 턴에 걸쳐 루돌프, 산타가 순서대로 움직인 후 게임 종료
# 7-2. P명 모두 탈락하면 그 즉시 게임 종료
# 7-3. 매 턴 이후 아직 안죽은 산타들 +1점
# 8. 게임이 끝났을 떄 각 산타가 얻은 최종 점수 출력

N, M, P, C, D = map(int, input().split()) # 겜판 크기, 겜턴수, 산타 수, 루돌프 힘, 산타 힘
ri, rj = map(int, input().split())
arr = [[0]*N for _ in range(N)]
ri-=1
rj-=1
arr[ri][rj] = -1
santa = [[] for _ in range(P+1)]
alert = [0]*(P+1)
for _ in range(P):
    idx, si, sj = map(int, input().split())
    santa[idx] = [si-1, sj-1]
    arr[si-1][sj-1] = idx
alive = [0]*(P+1)
alive[0] = 1 # 없는 산타
score = [0]*(P+1)
from collections import deque
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1] # 상우하좌 우선순위

def move_ru():
    # 1. 가까운 산타 찾기
    candidate = []
    min_dist = (N*N)**2
    for pidx in range(P+1):
        if alive[pidx] == 0:
            pi, pj = santa[pidx]
            dist = (ri-pi)**2+(rj-pj)**2
            if dist<min_dist:
                candidate = [[dist, -1*pi, -1*pj, pidx]]
                min_dist = dist
            elif dist==min_dist:
                candidate.append([dist, -1*pi, -1*pj, pidx])
    candidate.sort(key=lambda x:(x[0], x[1], x[2]))
    target = candidate[0][3]
    # 2. 가까운 산타로 가려면 어떤 방향으로 가야하는지
    si, sj = santa[target]
    min_dist = candidate[0][0]
    move = (-1,-1)
    new_coor = (-1, -1)
    for mi, mj in [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]:
        ni, nj = ri+mi, rj+mj
        dist = (si-ni)**2+(sj-nj)**2
        if dist<min_dist:
            min_dist = dist
            move = (mi, mj)
            new_coor = (ni, nj)
    # print('tg', target)
    return new_coor[0], new_coor[1], move, target

def move_santa():
    for idx in range(P+1):
        if not (alive[idx]==1 or alert[idx]>t):
            candidate = []
            pi, pj = santa[idx]
            min_dist = (ri-pi)**2+(rj-pj)**2
            for dr in range(4):
                ni, nj = pi+dx[dr], pj+dy[dr]
                if 0<=ni<N and 0<=nj<N and arr[ni][nj]<1:
                    dist = (ri-ni)**2+(rj-nj)**2
                    if dist<min_dist:
                        candidate = [[dx[dr], dy[dr]]]
                        min_dist = dist
            if candidate!=[]:
                x, y = candidate[0]
                arr[pi][pj] = 0
                santa[idx] = [pi + x, pj + y]
                # 루돌프 만났으면 상호작용
                if (pi+x, pj+y) == (ri, rj):
                    alert[idx] = t+2
                    effect(idx, (-1*x,-1*y), D)
                    score[idx] += D
                else:
                    arr[santa[idx][0]][santa[idx][1]] = idx

def effect(idx, dist, P):
    pi, pj = santa[idx]
    x, y = dist
    ni, nj = pi+(P*x), pj+(P*y)
    if 0<=ni<N and 0<=nj<N:
        if arr[ni][nj]>0:
            effect(arr[ni][nj], dist, 1)
        santa[idx] = [ni, nj]
        arr[ni][nj] = idx
    else:
        alive[idx] = 1


for t in range(M):
    if 0 not in alive:  break # 다 죽었으면 종료
    # 1. 루돌프 움직임 => move_ru()
    nri, nrj, dist, ts = move_ru() # 0, 1, (-1,-1), 타겟산타넘버
    # print(nri, nrj, dist, ts)
    if arr[nri][nrj] > 0:
        # 3. 상호작용
        alert[arr[nri][nrj]] = t+2
        score[arr[nri][nrj]] += C
        effect(arr[nri][nrj], dist, C)

    arr[ri][rj] = 0
    ri, rj = nri, nrj
    arr[nri][nrj] = -1
    # 2. 산타 움직임 => move_santa()
    move_santa()
    for s in range(P+1):
        if alive[s] == 0:
            score[s] += 1

    # print('sc',score)
    # print('arr',arr)
    # print('st',santa)
    # print('alive', alive)
    # print('alert', alert)
    # print(t, '-----------')
    # move_santa() # 내부에서 움직여서 부딪힐 때마다 상호작용 처리하기
    # break
print(*score[1:])

